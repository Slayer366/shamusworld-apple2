//
// AY-3-8910 Emulator
//
// This was written mainly from the General Instruments datasheet for the 8910
// part.  I would have used the one from MAME, but it was so poorly written and
// so utterly incomprehensible that I decided to start from scratch to see if I
// could do any better; and so here we are.  I did use a bit of code from
// MAME's AY-3-8910 RNG, as it was just too neat not to use.  :-)
//
// by James Hammons
// (C) 2018 Underground Software
//

#include "ay8910.h"

#include <string.h>			// for memset()
#include "log.h"
#include "sound.h"


struct AY_3_8910
{
	// User visible registers
	uint16_t period[3];		// Channel A-C period
	int16_t volume[3];		// Channel A-C volume (non-envelope mode)
	bool envEnable[3];		// Channel A-C envelope enable
	bool toneEnable[3];		// Channel A-C tone enable
	bool noiseEnable[3];	// Channel A-C noise enable
	uint16_t noisePeriod;	// Noise period (5 bits * 16)
	uint32_t envPeriod;		// Envelope period (16 bits * 256)
	bool envAttack;			// Envelope Attack bit
	bool envAlternate;		// Envelope Alternate bit
	bool envHold;			// Envelope Hold bit
	// Internal registers
	uint16_t count[3];		// Channel A-C current count
	bool state[3];			// Channel A-C current state
	uint16_t noiseCount;	// Noise current count
	bool noiseState;		// Noise state
	uint32_t envCount[3];	// Envelope current count
	int16_t envDirection[3];// Envelope direction (rising, 0, or falling)
	uint32_t prng;			// Psuedo RNG (17 bits)
};


// Maximum volume that can be generated by one voice
float maxVolume = 8192.0f;

// Normalized volumes (zero to one) for AY-3-8910 output, in 16 steps
static float normalizedVolume[16];// = {};

// AY-3-8910 register IDs
enum { AY_AFINE = 0, AY_ACOARSE, AY_BFINE, AY_BCOARSE, AY_CFINE, AY_CCOARSE,
	AY_NOISEPER, AY_ENABLE, AY_AVOL, AY_BVOL, AY_CVOL, AY_EFINE, AY_ECOARSE,
	AY_ESHAPE, AY_PORTA, AY_PORTB };

// Chip structs (for up to four separate chips)
static AY_3_8910 ay[4];


void AYInit(void)
{
	for(int chip=0; chip<4; chip++)
		AYReset(chip);

	// Our normalized volume levels are from 0 to -48 dB, in 3 dB steps.
	// N.B.: It's 3dB steps because those sound the best.  Dunno what it really
	//       is, as nothing in the documentation tells you (it only says that
	//       each channel's volume is normalized from 0 to 1.0V).
	float level = 1.0f;

	for(int i=15; i>=0; i--)
	{
		normalizedVolume[i] = level;
		level /= 1.4125375446228;	// 10.0 ^ (3.0 / 20.0) = 3 dB
	}

	// In order to get a scale that goes from 0 to 1 smoothly, we renormalize
	// our volumes so that volume[0] is actually 0, and volume[15] is 1.
	// Basically, we're sliding the curve down the Y-axis so that volume[0]
	// touches the X-axis, then stretching the result so that it fits into the
	// interval (0, 1).
	float vol0 = normalizedVolume[0];
	float vol15 = normalizedVolume[15] - vol0;

	for(int i=0; i<16; i++)
		normalizedVolume[i] = (normalizedVolume[i] - vol0) / vol15;

#if 0
	WriteLog("\nRenormalized volume, level (max=%d):\n", (int)maxVolume);
	for(int i=0; i<16; i++)
		WriteLog("%lf, %d\n", normalizedVolume[i], (int)(normalizedVolume[i] * maxVolume));
	WriteLog("\n");
#endif
}
/*
Renormalized:
0.000000, 0
0.002333, 13
0.005628, 33
0.010283, 61
0.016859, 101
0.026146, 156
0.039266, 235
0.057797, 346
0.083974, 503
0.120949, 725
0.173178, 1039
0.246954, 1481
0.351165, 2106
0.498366, 2990
0.706294, 4237
1.000000, 6000
*/


void AYReset(int chipNum)
{
	memset(&ay[chipNum], 0, sizeof(struct AY_3_8910));
	ay[chipNum].prng = 1;	// Set correct PRNG seed
}


void AYWrite(int chipNum, int reg, int value)
{
#if 0
static char regname[16][32] = {
	"AY_AFINE   ",
	"AY_ACOARSE ",
	"AY_BFINE   ",
	"AY_BCOARSE ",
	"AY_CFINE   ",
	"AY_CCOARSE ",
	"AY_NOISEPER",
	"AY_ENABLE  ",
	"AY_AVOL    ",
	"AY_BVOL    ",
	"AY_CVOL    ",
	"AY_EFINE   ",
	"AY_ECOARSE ",
	"AY_ESHAPE  ",
	"AY_PORTA   ",
	"AY_PORTB   "
};
WriteLog("*** AY(%d) Reg: %s = $%02X\n", chipNum, regname[reg], value);
#endif
	AY_3_8910 * chip = &ay[chipNum];
	value &= 0xFF;	// Ensure passed in value is no larger than 8 bits

	switch (reg)
	{
	case AY_AFINE:
		// The square wave period is the passed in value times 16, so we handle
		// that here.
		chip->period[0] = (chip->period[0] & 0xF000) | (value << 4);
		break;
	case AY_ACOARSE:
		chip->period[0] = ((value & 0x0F) << 12) | (chip->period[0] & 0xFF0);
		break;
	case AY_BFINE:
		chip->period[1] = (chip->period[1] & 0xF000) | (value << 4);
		break;
	case AY_BCOARSE:
		chip->period[1] = ((value & 0x0F) << 12) | (chip->period[1] & 0xFF0);
		break;
	case AY_CFINE:
		chip->period[2] = (chip->period[2] & 0xF000) | (value << 4);
		break;
	case AY_CCOARSE:
		chip->period[2] = ((value & 0x0F) << 12) | (chip->period[2] & 0xFF0);
		break;
	case AY_NOISEPER:
		// Like the square wave period, the value is the what's passed * 16.
		chip->noisePeriod = (value & 0x1F) << 4;
		break;
	case AY_ENABLE:
		chip->toneEnable[0] = (value & 0x01 ? false : true);
		chip->toneEnable[1] = (value & 0x02 ? false : true);
		chip->toneEnable[2] = (value & 0x04 ? false : true);
		chip->noiseEnable[0] = (value & 0x08 ? false : true);
		chip->noiseEnable[1] = (value & 0x10 ? false : true);
		chip->noiseEnable[2] = (value & 0x20 ? false : true);
		break;
	case AY_AVOL:
		chip->volume[0]    = value & 0x0F;
		chip->envEnable[0] = (value & 0x10 ? true : false);

		if (chip->envEnable[0])
		{
			chip->envCount[0]     = 0;
			chip->volume[0]       = (chip->envAttack ? 0 : 15);
			chip->envDirection[0] = (chip->envAttack ? 1 : -1);
		}
		break;
	case AY_BVOL:
		chip->volume[1]    = value & 0x0F;
		chip->envEnable[1] = (value & 0x10 ? true : false);

		if (chip->envEnable[1])
		{
			chip->envCount[1]     = 0;
			chip->volume[1]       = (chip->envAttack ? 0 : 15);
			chip->envDirection[1] = (chip->envAttack ? 1 : -1);
		}
		break;
	case AY_CVOL:
		chip->volume[2]    = value & 0x0F;
		chip->envEnable[2] = (value & 0x10 ? true : false);

		if (chip->envEnable[2])
		{
			chip->envCount[2]     = 0;
			chip->volume[2]       = (chip->envAttack ? 0 : 15);
			chip->envDirection[2] = (chip->envAttack ? 1 : -1);
		}
		break;
	case AY_EFINE:
		// The envelope period is 256 times the passed in value
		chip->envPeriod = (chip->envPeriod & 0xFF0000) | (value << 8);
		break;
	case AY_ECOARSE:
		chip->envPeriod = (value << 16) | (chip->envPeriod & 0xFF00);
		break;
	case AY_ESHAPE:
		chip->envAttack    = (value & 0x04 ? true : false);
		chip->envAlternate = (value & 0x02 ? true : false);
		chip->envHold      = (value & 0x01 ? true : false);

		// If the Continue bit is *not* set, the Alternate bit is forced to the
		// Attack bit, and Hold is forced on.
		if (!(value & 0x08))
		{
			chip->envAlternate = chip->envAttack;
			chip->envHold = true;
		}

		// Reset all voice envelope counts...
		for(int i=0; i<3; i++)
		{
			chip->envCount[i]     = 0;
			chip->envDirection[i] = (chip->envAttack ? 1 : -1);

			// Only reset the volume if the envelope is enabled!
			if (chip->envEnable[i])
				chip->volume[i] = (chip->envAttack ? 0 : 15);
		}
		break;
	}
}


//
// Generate one sample and quit
//
bool logAYInternal = false;
uint16_t AYGetSample(int chipNum)
{
	AY_3_8910 * chip = &ay[chipNum];
	uint16_t sample = 0;

	// Number of cycles per second to run the PSG is the 6502 clock rate
	// divided by the host sample rate
	const static double exactCycles = 1020484.32 / (double)SAMPLE_RATE;
	static double overflow = 0;

	int fullCycles = (int)exactCycles;
	overflow += exactCycles - (double)fullCycles;

	if (overflow >= 1.0)
	{
		fullCycles++;
		overflow -= 1.0;
	}

	for(int i=0; i<fullCycles; i++)
	{
		for(int j=0; j<3; j++)
		{
			// Tone generators only run if the corresponding voice is enabled.
			// N.B.: We also reject any period set that is less than 2.
			if (chip->toneEnable[j] && (chip->period[j] > 16))
			{
				chip->count[j]++;

				// It's (period / 2) because one full period of a square wave
				// is 0 for half of its period and 1 for the other half!
				if (chip->count[j] > (chip->period[j] / 2))
				{
					chip->count[j] = 0;
					chip->state[j] = !chip->state[j];
				}
			}

			// Envelope generator only runs if the corresponding voice flag is
			// enabled.
			if (chip->envEnable[j])
			{
				chip->envCount[j]++;

				// It's (EP / 16) because there are 16 volume steps in each EP.
				if (chip->envCount[j] > (chip->envPeriod / 16))
				{
					// Attack 0 = \, 1 = / (attack lasts one EP)
					// Alternate = mirror envelope's last attack
					// Hold = run 1 EP, hold at level (Alternate XOR Attack)
					chip->envCount[j] = 0;

					// We've hit a point where we need to make a change to the
					// envelope's volume, so do it:
					chip->volume[j] += chip->envDirection[j];

					// If we hit the end of the EP, change the state of the
					// envelope according to the envelope's variables.
					if ((chip->volume[j] > 15) || (chip->volume[j] < 0))
					{
						// Hold means we set the volume to (Alternate XOR
						// Attack) and stay there after the Attack EP.
						if (chip->envHold)
						{
							chip->volume[j] = (chip->envAttack != chip->envAlternate ? 15: 0);
							chip->envDirection[j] = 0;
						}
						else
						{
							// If the Alternate bit is set, we mirror the
							// Attack pattern; otherwise we reset it to the
							// whatever level was set by the Attack bit.
							if (chip->envAlternate)
							{
								chip->envDirection[j] = -chip->envDirection[j];
								chip->volume[j] += chip->envDirection[j];
							}
							else
								chip->volume[j] = (chip->envAttack ? 0 : 15);
						}
					}
				}
			}
		}

		// Noise generator (the PRNG) runs all the time:
		chip->noiseCount++;

		if (chip->noiseCount > chip->noisePeriod)
		{
			chip->noiseCount = 0;

			// The following is from MAME's AY-3-8910 code:
			// The Pseudo Random Number Generator of the 8910 is a 17-bit shift
			// register. The input to the shift register is bit0 XOR bit3 (bit0
			// is the output). This was verified on AY-3-8910 and YM2149 chips.

			// The following is a fast way to compute bit17 = bit0 ^ bit3.
			// Instead of doing all the logic operations, we only check bit0,
			// relying on the fact that after three shifts of the register,
			// what now is bit3 will become bit0, and will invert, if
			// necessary, bit14, which previously was bit17.
			if (chip->prng & 0x00001)
			{
				// This version is called the "Galois configuration".
				chip->prng ^= 0x24000;
				// The noise wave *toggles* when a one shows up in bit0...
				chip->noiseState = !chip->noiseState;
			}

			chip->prng >>= 1;
		}
	}

	// We mix channels A-C here into one sample, because the Mockingboard just
	// sums the output of the AY-3-8910 by tying their lines together.
	// We also handle the various cases (of which there are four) of mixing
	// pure tones and "noise" tones together.
	for(int i=0; i<3; i++)
	{
		// Set the volume level scaled by the maximum volume (which can be
		// altered outside of this module).
		int level = (int)(normalizedVolume[chip->volume[i]] * maxVolume);

		if (chip->toneEnable[i] && !chip->noiseEnable[i])
			sample += (chip->state[i] ? level : 0);
		else if (!chip->toneEnable[i] && chip->noiseEnable[i])
			sample += (chip->noiseState ? level : 0);
		else if (chip->toneEnable[i] && chip->noiseEnable[i])
			sample += (chip->state[i] & chip->noiseState ? level : 0);
		else if (!chip->toneEnable[i] && !chip->noiseEnable[i])
			sample += level;
	}

	if (logAYInternal)
	{
		WriteLog("    (%d) State A,B,C: %s %s %s, Sample: $%04X, P: $%X, $%X, $%X\n", chipNum, (chip->state[0] ? "1" : "0"), (chip->state[1] ? "1" : "0"), (chip->state[2] ? "1" : "0"), sample, chip->period[0], chip->period[1], chip->period[2]);
	}

	return sample;
}





// STUFF TO DELETE...

#if 0

/***************************************************************************

  ay8910.cpp

  Emulation of the AY-3-8910 / YM2149 sound chip.

  Based on various code snippets by Ville Hallik, Michael Cuddy,
  Tatsuyuki Satoh, Fabrice Frances, Nicola Salmoria.

***************************************************************************/

//
// From mame.txt (http://www.mame.net/readme.html)
//
// VI. Reuse of Source Code
// --------------------------
//    This chapter might not apply to specific portions of MAME (e.g. CPU
//    emulators) which bear different copyright notices.
//    The source code cannot be used in a commercial product without the
//    written authorization of the authors. Use in non-commercial products is
//    allowed, and indeed encouraged.  If you use portions of the MAME source
//    code in your program, however, you must make the full source code freely
//    available as well.
//    Usage of the _information_ contained in the source code is free for any
//    use. However, given the amount of time and energy it took to collect this
//    information, if you find new information we would appreciate if you made
//    it freely available as well.
//

// JLH: Commented out MAME specific crap

#define MAX_OUTPUT 0x7FFF

// See AY8910_set_clock() for definition of STEP
#define STEP 0x8000

struct AY8910
{
	int Channel;
	int SampleRate;
	int register_latch;
	unsigned char Regs[16];
	unsigned int UpdateStep;
	int PeriodA, PeriodB, PeriodC, PeriodN, PeriodE;
	int CountA, CountB, CountC, CountN, CountE;
	unsigned int VolA, VolB, VolC, VolE;
	unsigned char EnvelopeA, EnvelopeB, EnvelopeC;
	unsigned char OutputA, OutputB, OutputC, OutputN;
	signed char CountEnv;
	unsigned char Hold, Alternate, Attack, Holding;
	int RNG;
	unsigned int VolTable[32];
};

static struct AY8910 AYPSG[MAX_8910];		/* array of PSG's */

#define AY_AFINE	(0)
#define AY_ACOARSE	(1)
#define AY_BFINE	(2)
#define AY_BCOARSE	(3)
#define AY_CFINE	(4)
#define AY_CCOARSE	(5)
#define AY_NOISEPER	(6)
#define AY_ENABLE	(7)
#define AY_AVOL		(8)
#define AY_BVOL		(9)
#define AY_CVOL		(10)
#define AY_EFINE	(11)
#define AY_ECOARSE	(12)
#define AY_ESHAPE	(13)
//#define AY_PORTA	(14)
//#define AY_PORTB	(15)


void _AYWriteReg(int n, int r, int v)
{
#if 1
static char regname[16][32] = {
"AY_AFINE   ",
"AY_ACOARSE ",
"AY_BFINE   ",
"AY_BCOARSE ",
"AY_CFINE   ",
"AY_CCOARSE ",
"AY_NOISEPER",
"AY_ENABLE  ",
"AY_AVOL    ",
"AY_BVOL    ",
"AY_CVOL    ",
"AY_EFINE   ",
"AY_ECOARSE ",
"AY_ESHAPE  ",
"AY_PORTA   ",
"AY_PORTB   "
};
WriteLog("*** AY(%d) Reg: %s = $%02X\n", n, regname[r], v);
#endif
	struct AY8910 * PSG = &AYPSG[n];
	int old;

	PSG->Regs[r] = v;

	/* A note about the period of tones, noise and envelope: for speed reasons,
	 * we count down from the period to 0, but careful studies of the chip
	 * output prove that it instead counts up from 0 until the counter becomes
	 * greater or equal to the period. This is an important difference when the
	 * program is rapidly changing the period to modulate the sound.
	 * To compensate for the difference, when the period is changed we adjust
	 * our internal counter.
	 * Also, note that period = 0 is the same as period = 1. This is mentioned
	 * in the YM2203 data sheets. However, this does NOT apply to the Envelope
	 * period. In that case, period = 0 is half as period = 1.                  */
	switch (r)
	{
	case AY_AFINE:
	case AY_ACOARSE:
		PSG->Regs[AY_ACOARSE] &= 0x0F;
		old = PSG->PeriodA;
//		PSG->PeriodA = (PSG->Regs[AY_AFINE] + 256 * PSG->Regs[AY_ACOARSE]) * PSG->UpdateStep;
		PSG->PeriodA = ((PSG->Regs[AY_ACOARSE] << 8) | PSG->Regs[AY_AFINE]) * PSG->UpdateStep;

		if (PSG->PeriodA == 0)
			PSG->PeriodA = PSG->UpdateStep;

		PSG->CountA += PSG->PeriodA - old;

		if (PSG->CountA <= 0)
			PSG->CountA = 1;
		break;
	case AY_BFINE:
	case AY_BCOARSE:
		PSG->Regs[AY_BCOARSE] &= 0x0F;
		old = PSG->PeriodB;
		PSG->PeriodB = (PSG->Regs[AY_BFINE] + 256 * PSG->Regs[AY_BCOARSE]) * PSG->UpdateStep;

		if (PSG->PeriodB == 0)
			PSG->PeriodB = PSG->UpdateStep;

		PSG->CountB += PSG->PeriodB - old;

		if (PSG->CountB <= 0)
			PSG->CountB = 1;
		break;
	case AY_CFINE:
	case AY_CCOARSE:
		PSG->Regs[AY_CCOARSE] &= 0x0F;
		old = PSG->PeriodC;
		PSG->PeriodC = (PSG->Regs[AY_CFINE] + 256 * PSG->Regs[AY_CCOARSE]) * PSG->UpdateStep;

		if (PSG->PeriodC == 0)
			PSG->PeriodC = PSG->UpdateStep;

		PSG->CountC += PSG->PeriodC - old;

		if (PSG->CountC <= 0)
			PSG->CountC = 1;
		break;
	case AY_NOISEPER:
		PSG->Regs[AY_NOISEPER] &= 0x1F;
		old = PSG->PeriodN;
		PSG->PeriodN = PSG->Regs[AY_NOISEPER] * PSG->UpdateStep;

		if (PSG->PeriodN == 0)
			PSG->PeriodN = PSG->UpdateStep;

		PSG->CountN += PSG->PeriodN - old;

		if (PSG->CountN <= 0)
			PSG->CountN = 1;
		break;
/*	case AY_ENABLE:
		if ((PSG->lastEnable == -1) ||
		    ((PSG->lastEnable & 0x40) != (PSG->Regs[AY_ENABLE] & 0x40)))
		{
			// write out $FF if port set to input
			if (PSG->PortAwrite)
				(*PSG->PortAwrite)(0, (UINT8) ((PSG->Regs[AY_ENABLE] & 0x40) ? PSG->Regs[AY_PORTA] : 0xff));	// [TC: UINT8 cast]
		}

		if ((PSG->lastEnable == -1) ||
		    ((PSG->lastEnable & 0x80) != (PSG->Regs[AY_ENABLE] & 0x80)))
		{
			// write out $FF if port set to input
			if (PSG->PortBwrite)
				(*PSG->PortBwrite)(0, (UINT8) ((PSG->Regs[AY_ENABLE] & 0x80) ? PSG->Regs[AY_PORTB] : 0xff));	// [TC: UINT8 cast]
		}

		PSG->lastEnable = PSG->Regs[AY_ENABLE];
		break;*/
	case AY_AVOL:
		PSG->Regs[AY_AVOL] &= 0x1F;
		PSG->EnvelopeA = PSG->Regs[AY_AVOL] & 0x10;
		PSG->VolA = (PSG->EnvelopeA ? PSG->VolE :
			(PSG->VolTable[PSG->Regs[AY_AVOL] ? PSG->Regs[AY_AVOL] * 2 + 1
				: 0]));
		break;
	case AY_BVOL:
		PSG->Regs[AY_BVOL] &= 0x1F;
		PSG->EnvelopeB = PSG->Regs[AY_BVOL] & 0x10;
		PSG->VolB = (PSG->EnvelopeB ? PSG->VolE :
			(PSG->VolTable[PSG->Regs[AY_BVOL] ? PSG->Regs[AY_BVOL] * 2 + 1
				: 0]));
		break;
	case AY_CVOL:
		PSG->Regs[AY_CVOL] &= 0x1F;
		PSG->EnvelopeC = PSG->Regs[AY_CVOL] & 0x10;
		PSG->VolC = (PSG->EnvelopeC ? PSG->VolE
			: (PSG->VolTable[PSG->Regs[AY_CVOL] ? PSG->Regs[AY_CVOL] * 2 + 1
				: 0]));
		break;
	case AY_EFINE:
	case AY_ECOARSE:
		old = PSG->PeriodE;
		PSG->PeriodE = ((PSG->Regs[AY_EFINE] + 256 * PSG->Regs[AY_ECOARSE])) * PSG->UpdateStep;

		if (PSG->PeriodE == 0)
			PSG->PeriodE = PSG->UpdateStep / 2;

		PSG->CountE += PSG->PeriodE - old;

		if (PSG->CountE <= 0)
			PSG->CountE = 1;
		break;
	case AY_ESHAPE:
		/* envelope shapes:
		C AtAlH
		0 0 x x  \___

		0 1 x x  /___

		1 0 0 0  \\\\

		1 0 0 1  \___

		1 0 1 0  \/\/
		          ___
		1 0 1 1  \

		1 1 0 0  ////
		          ___
		1 1 0 1  /

		1 1 1 0  /\/\

		1 1 1 1  /___

		The envelope counter on the AY-3-8910 has 16 steps. On the YM2149 it
		has twice the steps, happening twice as fast. Since the end result is
		just a smoother curve, we always use the YM2149 behaviour.
		*/
		PSG->Regs[AY_ESHAPE] &= 0x0F;
		PSG->Attack = (PSG->Regs[AY_ESHAPE] & 0x04 ? 0x1F : 0x00);

		if ((PSG->Regs[AY_ESHAPE] & 0x08) == 0)
		{
			/* if Continue = 0, map the shape to the equivalent one which has Continue = 1 */
			PSG->Hold = 1;
			PSG->Alternate = PSG->Attack;
		}
		else
		{
			PSG->Hold = PSG->Regs[AY_ESHAPE] & 0x01;
			PSG->Alternate = PSG->Regs[AY_ESHAPE] & 0x02;
		}

		PSG->CountE = PSG->PeriodE;
		PSG->CountEnv = 0x1F;
		PSG->Holding = 0;
		PSG->VolE = PSG->VolTable[PSG->CountEnv ^ PSG->Attack];

		if (PSG->EnvelopeA)
			PSG->VolA = PSG->VolE;

		if (PSG->EnvelopeB)
			PSG->VolB = PSG->VolE;

		if (PSG->EnvelopeC)
			PSG->VolC = PSG->VolE;
		break;
/*	case AY_PORTA:
		if (PSG->Regs[AY_ENABLE] & 0x40)
		{
			if (PSG->PortAwrite)
				(*PSG->PortAwrite)(0, PSG->Regs[AY_PORTA]);
			else
				logerror("PC %04x: warning - write %02x to 8910 #%d Port A\n",activecpu_get_pc(),PSG->Regs[AY_PORTA],n);
		}
		else
		{
			logerror("warning: write to 8910 #%d Port A set as input - ignored\n",n);
		}
		break;
	case AY_PORTB:
		if (PSG->Regs[AY_ENABLE] & 0x80)
		{
			if (PSG->PortBwrite)
				(*PSG->PortBwrite)(0, PSG->Regs[AY_PORTB]);
			else
				logerror("PC %04x: warning - write %02x to 8910 #%d Port B\n",activecpu_get_pc(),PSG->Regs[AY_PORTB],n);
		}
		else
		{
			logerror("warning: write to 8910 #%d Port B set as input - ignored\n",n);
		}
		break;*/
	}
}


//#define DEBUG_AY
// /length/ is the number of samples we require
void AY8910Update(int chip, int16_t ** buffer, int length)	// [TC: Removed static]
{
#ifdef DEBUG_AY
WriteLog("AY8910Update: chip=%d, buffer=%X, length=%d\n", chip, buffer, length);
#endif
	struct AY8910 * PSG = &AYPSG[chip];

	int16_t * buf1 = buffer[0];
	int16_t * buf2 = buffer[1];
	int16_t * buf3 = buffer[2];

	/* The 8910 has three outputs, each output is the mix of one of the three
	 * tone generators and of the (single) noise generator. The two are mixed
	 * BEFORE going into the DAC. The formula to mix each channel is:
	 * (ToneOn | ToneDisable) & (NoiseOn | NoiseDisable).
	 * Note that this means that if both tone and noise are disabled, the
	 * output is 1, not 0, and can be modulated changing the volume.
	 *
	 * If the channels are disabled, set their output to 1, and increase the
	 * counter, if necessary, so they will not be inverted during this update.
	 * Setting the output to 1 is necessary because a disabled channel is
	 * locked into the ON state (see above); and it has no effect if the volume
	 * is 0. If the volume is 0, increase the counter, but don't touch the
	 * output.
	 */
	// N.B.: The bits in AY_ENABLE (0-5) are all active LOW, which means if the
	//       channel bit is set, it is DISABLED.  5-3 are noise, 2-0 tone.
	if (PSG->Regs[AY_ENABLE] & 0x01)
	{
		if (PSG->CountA <= length * STEP)
			PSG->CountA += length * STEP;

		PSG->OutputA = 1;
	}
	else if (PSG->Regs[AY_AVOL] == 0)
	{
		/* note that I do count += length, NOT count = length + 1. You might
		 * think it's the same since the volume is 0, but doing the latter
		 * could cause interferencies when the program is rapidly modulating
		 * the volume.
		 */
		if (PSG->CountA <= length * STEP)
			PSG->CountA += length * STEP;
	}

	if (PSG->Regs[AY_ENABLE] & 0x02)
	{
		if (PSG->CountB <= length * STEP)
			PSG->CountB += length * STEP;

		PSG->OutputB = 1;
	}
	else if (PSG->Regs[AY_BVOL] == 0)
	{
		if (PSG->CountB <= length * STEP)
			PSG->CountB += length * STEP;
	}

	if (PSG->Regs[AY_ENABLE] & 0x04)
	{
		if (PSG->CountC <= length * STEP)
			PSG->CountC += length * STEP;

		PSG->OutputC = 1;
	}
	else if (PSG->Regs[AY_CVOL] == 0)
	{
		if (PSG->CountC <= length * STEP)
			PSG->CountC += length * STEP;
	}

	/* for the noise channel we must not touch OutputN - it's also not
	 * necessary since we use outn.                                                        */
	if ((PSG->Regs[AY_ENABLE] & 0x38) == 0x38)	/* all off */
		if (PSG->CountN <= length * STEP)
			PSG->CountN += length * STEP;

	int outn = (PSG->OutputN | PSG->Regs[AY_ENABLE]);

#ifdef DEBUG_AY
WriteLog("AY8910Update: Stepping into while (length)...\n");
#endif
	/* buffering loop */
	while (length)
	{
		/* vola, volb and volc keep track of how long each square wave stays
		 * in the 1 position during the sample period.
		 */
		int vola = 0, volb = 0, volc = 0;
		int left = STEP;

#ifdef DEBUG_AY
WriteLog("AY8910Update: Stepping into inner do loop... (length=%d)\n", length);
#endif
		do
		{
			int nextevent = (PSG->CountN < left ? PSG->CountN : left);
//Note: nextevent is 0 here when first initialized...
//so let's try this:
			if (nextevent == 0)
				left = 0;
#ifdef DEBUG_AY
WriteLog("AY8910Update: nextevent=$%X, left=$%X\n", nextevent, left);
#endif

			if (outn & 0x08)
			{
				if (PSG->OutputA)
					vola += PSG->CountA;

				PSG->CountA -= nextevent;
				/* PeriodA is the half period of the square wave. Here, in each
				 * loop I add PeriodA twice, so that at the end of the loop the
				 * square wave is in the same status (0 or 1) it was at the
				 * start. vola is also incremented by PeriodA, since the wave
				 * has been 1 exactly half of the time, regardless of the
				 * initial position. If we exit the loop in the middle, OutputA
				 * has to be inverted and vola incremented only if the exit
				 * status of the square wave is 1.                                                      */
				while (PSG->CountA <= 0)
				{
					PSG->CountA += PSG->PeriodA;

					if (PSG->CountA > 0)
					{
						PSG->OutputA ^= 1;

						if (PSG->OutputA)
							vola += PSG->PeriodA;

						break;
					}

					PSG->CountA += PSG->PeriodA;
					vola += PSG->PeriodA;
				}

				if (PSG->OutputA)
					vola -= PSG->CountA;
			}
			else
			{
				PSG->CountA -= nextevent;

				while (PSG->CountA <= 0)
				{
					PSG->CountA += PSG->PeriodA;

					if (PSG->CountA > 0)
					{
						PSG->OutputA ^= 1;
						break;
					}

					PSG->CountA += PSG->PeriodA;
				}
			}

			if (outn & 0x10)
			{
				if (PSG->OutputB)
					volb += PSG->CountB;

				PSG->CountB -= nextevent;

				while (PSG->CountB <= 0)
				{
					PSG->CountB += PSG->PeriodB;

					if (PSG->CountB > 0)
					{
						PSG->OutputB ^= 1;

						if (PSG->OutputB)
							volb += PSG->PeriodB;
						break;
					}

					PSG->CountB += PSG->PeriodB;
					volb += PSG->PeriodB;
				}

				if (PSG->OutputB)
					volb -= PSG->CountB;
			}
			else
			{
				PSG->CountB -= nextevent;

				while (PSG->CountB <= 0)
				{
					PSG->CountB += PSG->PeriodB;

					if (PSG->CountB > 0)
					{
						PSG->OutputB ^= 1;
						break;
					}

					PSG->CountB += PSG->PeriodB;
				}
			}

			if (outn & 0x20)
			{
				if (PSG->OutputC)
					volc += PSG->CountC;

				PSG->CountC -= nextevent;

				while (PSG->CountC <= 0)
				{
					PSG->CountC += PSG->PeriodC;

					if (PSG->CountC > 0)
					{
						PSG->OutputC ^= 1;

						if (PSG->OutputC)
							volc += PSG->PeriodC;
						break;
					}

					PSG->CountC += PSG->PeriodC;
					volc += PSG->PeriodC;
				}

				if (PSG->OutputC)
					volc -= PSG->CountC;
			}
			else
			{
				PSG->CountC -= nextevent;

				while (PSG->CountC <= 0)
				{
					PSG->CountC += PSG->PeriodC;

					if (PSG->CountC > 0)
					{
						PSG->OutputC ^= 1;
						break;
					}

					PSG->CountC += PSG->PeriodC;
				}
			}

			PSG->CountN -= nextevent;

			if (PSG->CountN <= 0)
			{
				/* Is noise output going to change? */
				if ((PSG->RNG + 1) & 0x00002)	// (bit0 XOR bit1) == 1?
				{
					PSG->OutputN = ~PSG->OutputN;
					outn = (PSG->OutputN | PSG->Regs[AY_ENABLE]);
				}

				/* The Random Number Generator of the 8910 is a 17-bit shift
				 * register. The input to the shift register is bit0 XOR bit3
				 * (bit0 is the output). This was verified on AY-3-8910 and
				 * YM2149 chips.
				 *
				 * The following is a fast way to compute bit17 = bit0^bit3.
				 * Instead of doing all the logic operations, we only check
				 * bit0, relying on the fact that after three shifts of the
				 * register, what now is bit3 will become bit0, and will
				 * invert, if necessary, bit14, which previously was bit17.   */
				if (PSG->RNG & 0x00001)
					PSG->RNG ^= 0x24000; /* This version is called the "Galois configuration". */

				PSG->RNG >>= 1;
				PSG->CountN += PSG->PeriodN;
			}

			left -= nextevent;
		}
		while (left > 0);

#ifdef DEBUG_AY
WriteLog("AY8910Update: About to update envelope...\n");
#endif
		/* update envelope */
		if (PSG->Holding == 0)
		{
			PSG->CountE -= STEP;

			if (PSG->CountE <= 0)
			{
#ifdef DEBUG_AY
WriteLog("AY8910Update: About to enter do loop... (CountEnv = $%X, CountE =$%X, PeriodE = $%X)\n", PSG->CountEnv, PSG->CountE, PSG->PeriodE);
#endif
				// JLH: Sanity check...
				if (PSG->PeriodE > 0)
				{
					do
					{
						PSG->CountEnv--;
						PSG->CountE += PSG->PeriodE;
					}
					while (PSG->CountE <= 0);
				}

				/* check envelope current position */
				if (PSG->CountEnv < 0)
				{
					if (PSG->Hold)
					{
						if (PSG->Alternate)
							PSG->Attack ^= 0x1F;

						PSG->Holding = 1;
						PSG->CountEnv = 0;
					}
					else
					{
						/* if CountEnv has looped an odd number of times
						 * (usually 1), invert the output.                                         */
						if (PSG->Alternate && (PSG->CountEnv & 0x20))
 							PSG->Attack ^= 0x1F;

						PSG->CountEnv &= 0x1F;
					}
				}

				PSG->VolE = PSG->VolTable[PSG->CountEnv ^ PSG->Attack];

				/* reload volume */
				if (PSG->EnvelopeA)
					PSG->VolA = PSG->VolE;

				if (PSG->EnvelopeB)
					PSG->VolB = PSG->VolE;

				if (PSG->EnvelopeC)
					PSG->VolC = PSG->VolE;
			}
		}

#if 1
		*(buf1++) = (vola * PSG->VolA) / STEP;
		*(buf2++) = (volb * PSG->VolB) / STEP;
		*(buf3++) = (volc * PSG->VolC) / STEP;
#else	// [Tom's code...]
		// Output PCM wave [-32768...32767] instead of MAME's voltage level [0...32767]
		// - This allows for better s/w mixing

		if (PSG->VolA)
		{
			if (vola)
				*(buf1++) = (vola * PSG->VolA) / STEP;
			else
				*(buf1++) = -(int)PSG->VolA;
		}
		else
			*(buf1++) = 0;

		if (PSG->VolB)
		{
			if (volb)
				*(buf2++) = (volb * PSG->VolB) / STEP;
			else
				*(buf2++) = -(int)PSG->VolB;
		}
		else
			*(buf2++) = 0;

		if (PSG->VolC)
		{
			if (volc)
				*(buf3++) = (volc * PSG->VolC) / STEP;
			else
				*(buf3++) = -(int)PSG->VolC;
		}
		else
			*(buf3++) = 0;
#endif
		length--;
	}
#ifdef DEBUG_AY
WriteLog("AY8910Update: Done.\n");
#endif
}


static void AY8910_set_clock(int chip, int clock)
{
//	struct AY8910 * PSG = &AYPSG[chip];

	/* The step clock for the tone and noise generators is the chip clock
	 * divided by 8; for the envelope generator of the AY-3-8910, it is half
	 * that much (clock/16), but the envelope of the YM2149 goes twice as
	 * fast, therefore again clock/8.
	 * Here we calculate the number of steps which happen during one sample
	 * at the given sample rate. No. of events = sample rate / (clock/8).
	 * STEP is a multiplier used to turn the fraction into a fixed point
	 * number.
	 */
	AYPSG[chip].UpdateStep = (unsigned int)(((double)STEP * AYPSG[chip].SampleRate * 8 + clock / 2) / clock);	// [TC: unsigned int cast]
}


static void build_mixer_table(int chip)
{
	/* calculate the volume->voltage conversion table
	 * The AY-3-8910 has 16 levels, in a logarithmic scale (3dB per step)
	 * The YM2149 still has 16 levels for the tone generators, but 32 for
	 * the envelope generator (1.5dB per step).
	 */
	double out = MAX_OUTPUT;

	for(int i=31; i>0; i--)
	{
		AYPSG[chip].VolTable[i] = (unsigned int)(out + 0.5);	/* round to nearest */	// [TC: unsigned int cast]
		out /= 1.188502227;	/* = 10 ^ (1.5/20) = 1.5dB */
	}

	AYPSG[chip].VolTable[0] = 0;
}


void AY8910_reset(int chip)
{
	AYPSG[chip].register_latch = 0;
	AYPSG[chip].RNG = 1;
	AYPSG[chip].OutputA = 0;
	AYPSG[chip].OutputB = 0;
	AYPSG[chip].OutputC = 0;
	AYPSG[chip].OutputN = 0xFF;

	for(int i=0; i<=AY_ESHAPE; i++)
		_AYWriteReg(chip, i, 0);	/* AYWriteReg() uses the timer system; we
									 * cannot call it at this time because the
									 * timer system has not been initialized.                     */
}

// This stuff looks like Tom's code, so let's streamline and un-MSHungarianize this shit:
// [DONE]
// N.B.: Looks like 'clock' is the 65C02 clock rate, and 'sampleRate' is the
//       sample rate set by the audio subsystem.

void AY8910_InitAll(int clock, int sampleRate)
{
	for(int chip=0; chip<MAX_8910; chip++)
	{
		memset(&AYPSG[chip], 0, sizeof(struct AY8910));
		AYPSG[chip].SampleRate = sampleRate;
		AY8910_set_clock(chip, clock);
		build_mixer_table(chip);
	}
}


void AY8910_InitClock(int clock)
{
	for(int chip=0; chip<MAX_8910; chip++)
		AY8910_set_clock(chip, clock);
}
#endif

